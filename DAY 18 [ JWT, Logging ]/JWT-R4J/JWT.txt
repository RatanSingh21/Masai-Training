-----------------   JWT Implementation: Generation and Validation Flow ------------------------

JWT token is used instead of session-based authentication.
In session-based authentication, the server maintains a session for each user, storing session data on the server and using a session ID (stored in cookies) to identify the user.
JWT replaces this by storing all necessary user information in the token itself, eliminating the need for server-side session storage.

JWT Generation
  The JWT generation process typically occurs during user authentication (e.g., login or registration). Here's how it works:
    1. User Authentication:
        - The user provides credentials (e.g., username and password).
        - The application verifies the credentials against the database.
    2. Token Creation:
        - If authentication is successful, a JWT token is generated.
        - The token includes claims such as username, roles, and an expiration time.
        - The token is signed using a secret key.
    3. Token Response:
        - The generated token is sent back to the client in the response.

JWT Validation
  The JWT validation process ensures that incoming requests are authenticated and authorized.
    1. Intercept Request:
        - A filter (e.g., JwtValidatorFilter) intercepts every request.
    2. Extract Token:
        - The filter extracts the JWT token from the Authorization header.
    3. Validate Token:
        - The token is validated for integrity, expiration, and claims.
        - If valid, the user details are extracted, and authentication is set in the SecurityContext.
    4. Proceed with Request:
        - If the token is valid, the request proceeds to the controller.
        - If invalid, an error response is returned.

Integration:
    - Token generation occurs after successful authentication.
    - Implemented in the JwtGeneratorFilter and added to the filter chain after the BasicAuthenticationFilter.
    - This ensures the token is created only after the user is authenticated.
    - Token validation happens before the authentication process.
    - Implemented in the JwtValidatorFilter and added to the filter chain before the BasicAuthenticationFilter.
    - This ensures that incoming requests are validated for a valid token before proceeding further.
    - Defined in the SecurityConfig class.(both generation and validation filters)
    - Specifies the order of filters and the endpoints requiring authentication or specific roles.
    - Open endpoints like /register and /welcome bypass token validation, while protected endpoints like /welcome/auth and /admin require token validation and role-based access.

---------------- JWT Token Generation Scenarios ------------------------

First-time authentication (Register & Login):
    - Use the utility class (JwtUtil) to manually generate the JWT token in the controller.
    - This is necessary because the user is not yet authenticated, so the filter cannot generate the token.

Other scenarios (Authenticated requests):
    - Use the filter (JwtGeneratorFilter) to automatically generate and attach the JWT token to the response header.
    - The filter works after authentication, ensuring consistent token generation for protected endpoints.

Step to implement Spring security package in our project
    1. Add Spring Security dependency in pom.xml
    2. Create a SecurityConfig class to configure security settings.
    3. Create custom filters for JWT generation and validation.
    4. Implement UserDetails interface to represent user details.
    5. Implement UserDetailsService to load user-specific data.
    6. Create a utility class for JWT operations (generation and validation).
    7. Configure filter chain in SecurityConfig to include custom filters.
    8. Test the implementation using Postman or any API testing tool.

Conclusion :
    JWTGeneration should not be used as filter
    Use in Util package

---------------- Logging ------------------------

Logging is essential for monitoring applications, troubleshooting, and auditing.
SLF4J stands for Simple Logging Facade for Java. Facade is like a plugin
It acts as an abstraction layer for various logging frameworks, allowing developers to plug in the desired logging framework at deployment time without changing the source code.
Logback is one of the logging frameworks that can be used behind SLF4J. It is considered a successor to Log4J and provides powerful and flexible logging capabilities.
In Spring Boot applications, SLF4J is commonly used with Logback as the default logging implementation.
Types of Logging Framework:
    Java Util Log (JUL) - BASIC
    Logback - popular
    Log4J - Advanced and complex

Logging levels in order of severity:
    - ERROR: For serious issues that might cause the application to fail.
    - WARN: Indicates a potential problem or important situation that is not an error.
    - INFO: General information about the application's running state.
    - DEBUG: Used for detailed debugging information.
    - TRACE: More fine-grained than DEBUG, used for tracing program execution.
By default, INFO, WARN, and ERROR are enabled.To enable DEBUG or TRACE, you need to configure the application properties.

Logging in Spring Boot:
    1. Add SLF4J and Logback dependencies (usually included by default in Spring Boot).
    2. Use the LoggerFactory to create a logger instance in your classes.
    3. Use the logger to log messages at different levels (INFO, DEBUG, ERROR, etc.).
    4. Configure logging settings in application.properties or application.yml if needed.

Application.properties  example:
    Sets the root logging level to INFO for all loggers.
    Enables DEBUG logging for the in.ratansgh.JWT_R4J package and for Spring Security.
    Logs are written to a file named application.log.
    Customizes the console log format to show date, time, and message.
    Customizes the file log format to show date, time, thread, log level, logger name, and message.

Enable only TRACE this will enable all levels -- >>logging.level.root=TRACE

